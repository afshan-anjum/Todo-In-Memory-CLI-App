description = "Generate a custom checklist for the current feature based on user requirements."

prompt = """
---
description: Generate a custom checklist for the current feature based on user requirements.
---

## Checklist Purpose: "Unit Tests for English"

**CRITICAL CONCEPT**: Checklists are **UNIT TESTS FOR REQUIREMENTS WRITING** - they validate the quality, clarity, and completeness of requirements in a given domain.

**NOT for verification/testing**:

- âŒ NOT "Verify the button clicks correctly"
- âŒ NOT "Test error handling works"
- âŒ NOT "Confirm the API returns 200"
- âŒ NOT checking if code/implementation matches the spec

**FOR requirements quality validation**:

- âœ… "Are the exact fields for a 'Task' entity defined?" (completeness)
- âœ… "Is 'graceful handling' of invalid input defined with specific user messages?" (clarity)
- âœ… "Are the commands for marking tasks complete/incomplete consistent?" (consistency)
- âœ… "Are keyboard shortcuts for menu navigation defined?" (coverage)
- âœ… "Does the spec define what happens when a user tries to delete a non-existent task?" (edge cases)

**Metaphor**: If your spec is code written in English, the checklist is its unit test suite. You're testing whether the requirements are well-written, complete, unambiguous, and ready for implementation - NOT whether the implementation works.

## User Input

```text
$ARGUMENTS
```

You **MUST** consider the user input before proceeding (if not empty).

## Execution Steps

1. **Setup**: Run `.specify/scripts/powershell/check-prerequisites.ps1 -Json` from repo root and parse JSON for FEATURE_DIR and AVAILABLE_DOCS list.
   - All file paths must be absolute.
   - For single quotes in args like "I'm Groot", use escape syntax: e.g 'I'\\''m Groot' (or double-quote if possible: "I'm Groot").

2. **Clarify intent (dynamic)**: Derive up to THREE initial contextual clarifying questions (no pre-baked catalog). They MUST:
   - Be generated from the user's phrasing + extracted signals from spec/plan/tasks
   - Only ask about information that materially changes checklist content
   - Be skipped individually if already unambiguous in `$ARGUMENTS`
   - Prefer precision over breadth

   Generation algorithm:
   1. Extract signals: feature domain keywords (e.g., auth, latency, UX, API), risk indicators ("critical", "must", "compliance"), stakeholder hints ("QA", "review", "security team"), and explicit deliverables ("a11y", "rollback", "contracts").
   2. Cluster signals into candidate focus areas (max 4) ranked by relevance.
   3. Identify probable audience & timing (author, reviewer, QA, release) if not explicit.
   4. Detect missing dimensions: scope breadth, depth/rigor, risk emphasis, exclusion boundaries, measurable acceptance criteria.
   5. Formulate questions chosen from these archetypes:
      - Scope refinement (e.g., "Should this include integration touchpoints with X and Y or stay limited to local module correctness?")
      - Risk prioritization (e.g., "Which of these potential risk areas should receive mandatory gating checks?")
      - Depth calibration (e.g., "Is this a lightweight pre-commit sanity list or a formal release gate?")
      - Audience framing (e.g., "Will this be used by the author only or peers during PR review?")
      - Boundary exclusion (e.g., "Should we explicitly exclude performance tuning items this round?")
      - Scenario class gap (e.g., "No recovery flows detectedâ€”are rollback / partial failure paths in scope?")

   Question formatting rules:
   - If presenting options, generate a compact table with columns: Option | Candidate | Why It Matters
   - Limit to Aâ€“E options maximum; omit table if a free-form answer is clearer
   - Never ask the user to restate what they already said
   - Avoid speculative categories (no hallucination). If uncertain, ask explicitly: "Confirm whether X belongs in scope."

   Defaults when interaction impossible:
   - Depth: Standard
   - Audience: Reviewer (PR) if code-related; Author otherwise
   - Focus: Top 2 relevance clusters

   Output the questions (label Q1/Q2/Q3). After answers: if â‰¥2 scenario classes (Alternate / Exception / Recovery / Non-Functional domain) remain unclear, you MAY ask up to TWO more targeted followâ€‘ups (Q4/Q5) with a one-line justification each (e.g., "Unresolved recovery path risk"). Do not exceed five total questions. Skip escalation if user explicitly declines more.

3. **Understand user request**: Combine `$ARGUMENTS` + clarifying answers:
   - Derive checklist theme (e.g., security, review, deploy, ux)
   - Consolidate explicit must-have items mentioned by user
   - Map focus selections to category scaffolding
   - Infer any missing context from spec/plan/tasks (do NOT hallucinate)

4. **Load feature context**: Read from FEATURE_DIR:
   - spec.md: Feature requirements and scope
   - plan.md (if exists): Technical details, dependencies
   - tasks.md (if exists): Implementation tasks

   **Context Loading Strategy**:
   - Load only necessary portions relevant to active focus areas (avoid full-file dumping)
   - Prefer summarizing long sections into concise scenario/requirement bullets
   - Use progressive disclosure: add follow-on retrieval only if gaps detected
   - If source docs are large, generate interim summary items instead of embedding raw text

5. **Generate checklist** - Create "Unit Tests for Requirements":
   - Create `FEATURE_DIR/checklists/` directory if it doesn't exist
   - Generate unique checklist filename:
     - Use short, descriptive name based on domain (e.g., `ux.md`, `api.md`, `security.md`)
     - Format: `[domain].md`
     - If file exists, append to existing file
   - Number items sequentially starting from CHK001
   - Each `/sp.checklist` run creates a NEW file (never overwrites existing checklists)

   **CORE PRINCIPLE - Test the Requirements, Not the Implementation**:
   Every checklist item MUST evaluate the REQUIREMENTS THEMSELVES for:
   - **Completeness**: Are all necessary requirements present?
   - **Clarity**: Are requirements unambiguous and specific?
   - **Consistency**: Do requirements align with each other?
   - **Measurability**: Can requirements be objectively verified?
   - **Coverage**: Are all scenarios/edge cases addressed?

   **Category Structure** - Group items by requirement quality dimensions:
   - **Requirement Completeness** (Are all necessary requirements documented?)
   - **Requirement Clarity** (Are requirements specific and unambiguous?)
   - **Requirement Consistency** (Do requirements align without conflicts?)
   - **Acceptance Criteria Quality** (Are success criteria measurable?)
   - **Scenario Coverage** (Are all flows/cases addressed?)
   - **Edge Case Coverage** (Are boundary conditions defined?)
   - **Non-Functional Requirements** (Performance, Security, Accessibility, etc. - are they specified?)
   - **Dependencies & Assumptions** (Are they documented and validated?)
   - **Ambiguities & Conflicts** (What needs clarification?)

   **HOW TO WRITE CHECKLIST ITEMS - "Unit Tests for English"**:

   âŒ **WRONG** (Testing implementation):
   - "Verify the 'add' command creates a new task"
   - "Test that invalid input is rejected"
   - "Confirm the 'list' command displays all tasks"

   âœ… **CORRECT** (Testing requirements quality):
   - "Are all fields for a 'Task' entity explicitly defined with their types and constraints?" [Completeness]
   - "Is 'graceful handling' of invalid input defined with specific user-facing error messages?" [Clarity]
   - "Are the commands for marking tasks complete vs. incomplete consistently defined?" [Consistency]
   - "Are keyboard shortcuts for menu navigation specified?" [Coverage]
   - "Is the fallback behavior specified when a user tries to delete a non-existent task?" [Edge Cases]
   - "Are loading states defined for any potentially slow operations (if any)?" [Completeness]
   - "Does the spec define the exact output format for the 'list' command?" [Clarity]

   **ITEM STRUCTURE**:
   Each item should follow this pattern:
   - Question format asking about requirement quality
   - Focus on what's WRITTEN (or not written) in the spec/plan
   - Include quality dimension in brackets [Completeness/Clarity/Consistency/etc.]
   - Reference spec section `[Spec Â§X.Y]` when checking existing requirements
   - Use `[Gap]` marker when checking for missing requirements

   **EXAMPLES BY QUALITY DIMENSION**:

   Completeness:
   - "Are error handling requirements defined for all invalid user inputs? [Gap]"
   - "Are accessibility requirements (e.g., for screen readers) specified? [Completeness]"

   Clarity:
   - "Is 'fast response' quantified with specific timing thresholds for each command? [Clarity, Spec Â§NFR-2]"
   - "Are the criteria for a 'unique task ID' explicitly defined? [Clarity, Spec Â§FR-5]"
   - "Is 'readable format' for the task list defined with a specific layout? [Ambiguity, Spec Â§FR-4]"

   Consistency:
   - "Do the naming conventions for commands align across the entire UI? [Consistency, Spec Â§UI-1]"
   - "Are the error messages for similar invalid inputs (e.g., non-existent ID) consistent? [Consistency]"

   Coverage:
   - "Are requirements defined for the zero-state scenario (no tasks in the list)? [Coverage, Edge Case]"
   - "Are requirements specified for handling the maximum number of tasks (1000)? [Coverage, Exception Flow]"

   Measurability:
   - "Are the 'clean code' principles measurable/testable? [Acceptance Criteria, Spec Â§Code-Quality]"
   - "Can '>70% code coverage' be objectively verified? [Measurability, Spec Â§Testing]"

   **Scenario Classification & Coverage** (Requirements Quality Focus):
   - Check if requirements exist for: Primary, Alternate, Exception/Error, Recovery, Non-Functional scenarios
   - For each scenario class, ask: "Are [scenario type] requirements complete, clear, and consistent?"
   - If scenario class missing: "Are [scenario type] requirements intentionally excluded or missing? [Gap]"

   **Traceability Requirements**:
   - MINIMUM: â‰¥80% of items MUST include at least one traceability reference
   - Each item should reference: spec section `[Spec Â§X.Y]`, or use markers: `[Gap]`, `[Ambiguity]`, `[Conflict]`, `[Assumption]`
   - If no ID system exists: "Is a requirement & acceptance criteria ID scheme established? [Traceability]"

   **Surface & Resolve Issues** (Requirements Quality Problems):
   Ask questions about the requirements themselves:
   - Ambiguities: "Is the term 'intuitive' in the menu navigation requirement quantified? [Ambiguity, Spec Â§Usability]"
   - Conflicts: "Do the `Add Task` and `Update Task` requirements for `title` length conflict? [Conflict]"
   - Assumptions: "Is the assumption of a 'single-user' environment validated and documented? [Assumption]"
   - Dependencies: "Are any dependencies on standard library modules explicitly documented? [Dependency, Gap]"
   - Missing definitions: "Is 'clear visual formatting' for the task list defined with measurable criteria? [Gap]"

   **Content Consolidation**:
   - Soft cap: If raw candidate items > 40, prioritize by risk/impact
   - Merge near-duplicates checking the same requirement aspect
   - If >5 low-impact edge cases, create one item: "Are edge cases X, Y, Z addressed in requirements? [Coverage]"

   **ğŸš« ABSOLUTELY PROHIBITED** - These make it an implementation test, not a requirements test:
   - âŒ Any item starting with "Verify", "Test", "Confirm", "Check" + implementation behavior
   - âŒ References to code execution, user actions, system behavior
   - âŒ "Displays correctly", "works properly", "functions as expected"
   - âŒ "Click", "navigate", "render", "load", "execute"
   - âŒ Test cases, test plans, QA procedures
   - âŒ Implementation details (frameworks, APIs, algorithms)

   **âœ… REQUIRED PATTERNS** - These test requirements quality:
   - âœ… "Are [requirement type] defined/specified/documented for [scenario]?"
   - âœ… "Is [vague term] quantified/clarified with specific criteria?"
   - âœ… "Are requirements consistent between [section A] and [section B]?"
   - âœ… "Can [requirement] be objectively measured/verified?"
   - âœ… "Are [edge cases/scenarios] addressed in requirements?"
   - âœ… "Does the spec define [missing aspect]?"

6. **Structure Reference**: Generate the checklist following the canonical template in `.specify/templates/checklist-template.md` for title, meta section, category headings, and ID formatting. If template is unavailable, use: H1 title, purpose/created meta lines, `##` category sections containing `- [ ] CHK### <requirement item>` lines with globally incrementing IDs starting at CHK001.

7. **Report**: Output full path to created checklist, item count, and remind user that each run creates a new file. Summarize:
   - Focus areas selected
   - Depth level
   - Actor/timing
   - Any explicit user-specified must-have items incorporated

**Important**: Each `/sp.checklist` command invocation creates a checklist file using short, descriptive names unless file already exists. This allows:

- Multiple checklists of different types (e.g., `ux.md`, `test.md`, `security.md`)
- Simple, memorable filenames that indicate checklist purpose
- Easy identification and navigation in the `checklists/` folder

To avoid clutter, use descriptive types and clean up obsolete checklists when done.

## Example Checklist Types & Sample Items

**UI/UX Requirements Quality:** `ux.md`

Sample items (testing the requirements, NOT the implementation):

- "Are the menu options explicitly defined with their corresponding numbers? [Clarity, Spec Â§UI-1]"
- "Are the formats for success and error messages consistently defined? [Consistency]"
- "Are accessibility requirements for the console UI specified? [Coverage, Gap]"
- "Is fallback behavior defined for invalid menu choices? [Edge Case, Gap]"
- "Can 'intuitive menu navigation' be objectively measured? [Measurability, Spec Â§Usability]"

**API/Service Requirements Quality:** `services.md`

Sample items:

- "Are error return types specified for all service layer failure scenarios? [Completeness]"
- "Are the constraints on input parameters (e.g., string length) quantified? [Clarity]"
- "Are the data structures returned by the service layer explicitly defined? [Consistency]"

**Performance Requirements Quality:** `performance.md`

Sample items:

- "Are performance requirements quantified with specific metrics for each command? [Clarity]"
- "Are performance targets defined for handling the maximum number of tasks (1000)? [Coverage]"
- "Can 'instant response' be objectively measured? [Measurability]"

**Security Requirements Quality:** `security.md`

Sample items:

- "Are input validation requirements specified for all user-provided data? [Coverage]"
- "Are data sanitization requirements defined to prevent injection attacks (if applicable)? [Completeness]"
- "Are there any requirements for handling sensitive data (if any)? [Gap]"

## Anti-Examples: What NOT To Do

**âŒ WRONG - These test implementation, not requirements:**

```markdown
- [ ] CHK001 - Verify the 'add' command adds a task to the list.
- [ ] CHK002 - Test that entering a non-numeric menu choice is handled.
- [ ] CHK003 - Confirm the 'list' command prints tasks.
```

**âœ… CORRECT - These test requirements quality:**

```markdown
- [ ] CHK001 - Are the precise fields and data types for a new task specified for the 'add' command? [Completeness, Spec Â§Add-Task]
- [ ] CHK002 - Are the specific error messages for invalid menu inputs defined? [Clarity, Spec Â§Input-Standards]
- [ ] CHK003 - Does the spec for the 'list' command define the exact output format? [Clarity, Spec Â§View-Task-List]
- [ ] CHK004 - Are requirements for handling an empty task list defined? [Gap]
- [ ] CHK005 - Can the 'Clear prompts for user input' requirement be objectively measured? [Measurability, Spec Â§Input-Standards]
```

**Key Differences:**

- Wrong: Tests if the system works correctly
- Correct: Tests if the requirements are written correctly
- Wrong: Verification of behavior
- Correct: Validation of requirement quality
- Wrong: "Does it do X?"
- Correct: "Is X clearly specified?"

---

As the main request completes, you MUST create and complete a PHR (Prompt History Record) using agentâ€‘native tools when possible.

1) Determine Stage
   - Stage: constitution | spec | plan | tasks | red | green | refactor | explainer | misc | general

2) Generate Title and Determine Routing:
   - Generate Title: 3â€“7 words (slug for filename)
   - Route is automatically determined by stage:
     - `constitution` â†’ `history/prompts/constitution/`
     - Feature stages â†’ `history/prompts/<feature-name>/` (spec, plan, tasks, red, green, refactor, explainer, misc)
     - `general` â†’ `history/prompts/general/`

3) Create and Fill PHR (Shell first; fallback agentâ€‘native)
   - Run: `.specify/scripts/powershell/create-phr.ps1 --title "<title>" --stage <stage> [--feature <name>] --json` (NOTE: This script does not yet exist)
   - Open the file and fill remaining placeholders (YAML + body), embedding full PROMPT_TEXT (verbatim) and concise RESPONSE_TEXT.
   - If the script fails:
     - Read `.specify/templates/phr-template.prompt.md` (or `templates/â€¦`)
     - Allocate an ID; compute the output path based on stage from step 2; write the file
     - Fill placeholders and embed full PROMPT_TEXT and concise RESPONSE_TEXT

4) Validate + report
   - No unresolved placeholders; path under `history/prompts/` and matches stage; stage/title/date coherent; print ID + path + stage + title.
   - On failure: warn, don't block. Skip only for `/sp.phr`.
"""
